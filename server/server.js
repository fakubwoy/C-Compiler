require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const { exec } = require('child_process');
const fs = require('fs');
const axios = require('axios');

const app = express();
const PORT = 5000;

app.use(cors());
app.use(bodyParser.json());

const contextText = `Compilation is the process of translating source code written in a high-level programming language into machine code or an intermediate form that can be executed by a computer. This process involves several distinct phases, each with its own specific function and importance. The compilation process can typically be divided into the following major phases:

1. Lexical Analysis
Definition: Lexical analysis is the first phase of compilation, where the source code is read and converted into tokens.

Process:

Tokenization: The compiler scans the input source code character by character to identify meaningful sequences, called tokens. Tokens can represent keywords, identifiers, operators, literals, and punctuation.
Removing Whitespace and Comments: During this phase, whitespace characters and comments are usually ignored, as they do not affect the program’s functionality.
Symbol Table Creation: A symbol table is often created during lexical analysis to keep track of identifiers (like variable names and function names) and their attributes (such as data types).
Output: The output of this phase is a list of tokens, which serve as the input for the next phase.

2. Syntax Analysis
Definition: Syntax analysis, or parsing, is the second phase where the sequence of tokens generated by the lexical analyzer is analyzed according to the grammatical rules of the programming language.

Process:

Parsing: The compiler constructs a parse tree or abstract syntax tree (AST) from the tokens. This tree structure reflects the hierarchical syntactic structure of the program.
Grammar Rules: The parser uses context-free grammar rules to determine whether the sequence of tokens adheres to the language’s syntax. If there are any violations, syntax errors are reported.
Output: The result of this phase is typically an abstract syntax tree (AST) that represents the logical structure of the source code.

3. Semantic Analysis
Definition: Semantic analysis checks the AST generated in the syntax analysis phase for semantic consistency and correctness.

Process:

Type Checking: The compiler verifies that the operations in the code are semantically valid (e.g., checking that variables are used consistently according to their declared types).
Scope Resolution: The compiler checks variable scopes to ensure that identifiers are declared before they are used.
Symbol Table Usage: The symbol table created during lexical analysis is used here to validate identifier attributes and ensure proper usage.
Output: The output of semantic analysis is an annotated AST, which contains additional information, such as type information and other semantic attributes.

4. Intermediate Code Generation
Definition: This phase involves translating the annotated AST into an intermediate representation (IR), which is more abstract than machine code but closer to it than the source code.

Process:

Intermediate Representation: The compiler generates IR, which may be in the form of three-address code, bytecode, or other forms that simplify the next phases of compilation.
Machine Independence: The intermediate code is typically designed to be machine-independent, allowing for easier optimization and code generation for different target architectures.
Output: The output is the intermediate code representation of the original source code.

5. Code Optimization
Definition: Code optimization is the phase where the intermediate code is improved for performance and efficiency.

Process:

Local Optimization: This involves making improvements within basic blocks (sequences of instructions with no branches).
Global Optimization: More complex transformations may analyze the entire program to improve performance, such as eliminating dead code or unnecessary calculations.
Loop Optimization: Techniques like loop unrolling or invariant code motion are applied to enhance loop performance.
Output: The output of this phase is an optimized version of the intermediate code.

6. Code Generation
Definition: Code generation is the process of converting the optimized intermediate code into machine code specific to the target architecture.

Process:

Target Architecture Mapping: The compiler translates the intermediate representation into assembly or machine language instructions that correspond to the target CPU architecture.
Register Allocation: During this phase, the compiler decides how to allocate registers to hold temporary variables and results of computations.
Instruction Selection: The appropriate machine instructions are selected based on the intermediate representation.
Output: The output of this phase is the machine code or assembly language code that can be executed by the target machine.

7. Code Optimization (Post-Code Generation)
Definition: After initial code generation, further optimizations may be applied to the machine code.

Process:

Machine-Specific Optimization: This phase can involve optimization techniques that are specific to the machine architecture, such as instruction scheduling or optimizing for specific CPU features.
Linking and Assembly: If multiple source files are involved, linking combines them into a single executable, resolving references and creating a complete program.
Output: The final output is a fully optimized executable code ready for execution.

8. Error Handling and Reporting
Throughout the Compilation Process: Error handling is an integral part of compilation. Errors may be detected during any phase of the compilation, including lexical, syntactic, or semantic errors. The compiler must provide meaningful error messages to aid developers in diagnosing and fixing issues in the source code.

Summary
In summary, the phases of compilation work together to transform high-level source code into executable machine code. Each phase has its own responsibilities, and they collectively ensure that the final output is efficient and free of errors. By breaking down the compilation process into these distinct phases, compilers can systematically analyze, optimize, and generate code, 
making the development of software more robust and efficient.`;

app.post('/compile', (req, res) => {
    const asmCode = req.body.code;

    fs.writeFileSync('temp.asm', asmCode);

    exec('nasm -f elf64 temp.asm && ld -o output temp.o', (error, stdout, stderr) => {
        if (error) {
            console.error(`Error: ${stderr}`);
            return res.status(500).send('Compilation error');
        }

        res.download('output', 'output', (err) => {
            if (err) {
                console.error(err);
            }

            fs.unlinkSync('temp.asm');
            fs.unlinkSync('output');
            fs.unlinkSync('temp.o');
        });
    });
});

app.post('/chat', async (req, res) => {
  const { message } = req.body;

  try {
    const response = await axios.post(
      'https://api-inference.huggingface.co/models/distilbert-base-uncased-distilled-squad',
      {
        inputs: {
          question: message,
          context: contextText,
        },
      },
      {
        headers: {
          Authorization: `Bearer ${process.env.HUGGINGFACE_API_KEY}`,
        },
      }
    );

    const botReply = response.data?.answer || "I'm not sure about that. Can you try asking something else?";
    res.json({ reply: botReply });
  } catch (error) {
    console.error(error);
    res.status(500).json({ 
      error: 'Sorry, I encountered an error while processing your request.' 
    });
  }
});

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});